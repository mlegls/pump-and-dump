// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

const Qs = require('qs');
const Types = require('./Types.js');
const Axios = require('axios');
const Ethers = require('ethers');
const $$Promise = require('./Promise.js');
const Constants = require('./Constants.js');
const Caml_array = require('rescript/lib/js/caml_array.js');
const Caml_option = require('rescript/lib/js/caml_option.js');
const AWSHttpProvider = require('@aws/web3-http-provider');
const DiscordJsSelfbotV11 = require('discord.js-selfbot-v11');
const IERC20Json = require('@uniswap/v2-core/build/IERC20.json');
const IUniswapV2PairJson = require('@uniswap/v2-core/build/IUniswapV2Pair.json');

const myClient = new DiscordJsSelfbotV11.Client();

const awsProvider = new AWSHttpProvider(Constants.endpoint, Constants.credentials);
const myProvider = new Ethers.ethers.providers.Web3Provider(awsProvider);

const myWallet = new Ethers.ethers.Wallet(Constants.eth_wallet_private_key, myProvider);

function isEthPairLink(s) {
  if (s.includes('http')) {
    return s.includes('eth');
  } else {
    return false;
  }
}

function addressFromUrl(s) {
  const regexResult = /0x.{40}/.exec(s);
  if (regexResult === null) {
    return;
  }
  const pairAddress = Caml_array.get(regexResult, 0);
  if (!(pairAddress == null)) {
    return pairAddress;
  }
}

function addressFromMessage(msg) {
  const splitMessage = msg.split(' ');
  const len = splitMessage.length;
  if (len === 1) {
    return;
  }
  if (len === 0) {
    return;
  }
  if (Caml_array.get(splitMessage, 0) !== '<@&882669674771406889>') {
    return;
  }
  const pairLinks = splitMessage.filter(isEthPairLink);
  const len$1 = pairLinks.length;
  if (len$1 !== 1) {
    if (len$1 !== 0) {
      return addressFromUrl(Caml_array.get(pairLinks, 0));
    } else {
      return;
    }
  } else {
    return addressFromUrl(pairLinks[0]);
  }
}

function tokenFromPair(pairAddress) {
  const pairContract = new Ethers.ethers.Contract(pairAddress, IUniswapV2PairJson.abi, myProvider);
  return pairContract.token0().then(function(token0) {
    return Promise.resolve(token0);
  });
}

function zrxQuery(buyToken, sellTokenOpt, sellAmountOpt, requestTypeOpt, param) {
  const sellToken = sellTokenOpt !== undefined ? sellTokenOpt : ({
    TAG: /* TokenName */1,
    _0: 'ETH',
  });
  const sellAmount = sellAmountOpt !== undefined ? sellAmountOpt : Constants.sell_amount;
  const requestType = requestTypeOpt !== undefined ? requestTypeOpt : /* Price */0;
  const body = {
    buyToken: buyToken._0,
    sellToken: sellToken._0,
    sellAmount: sellAmount,
  };
  const body$1 = Qs.stringify(body);
  const queryString = body$1 !== undefined ? Caml_option.valFromOption(body$1) : '';
  const request = requestType ? 'https://api.0x.org/swap/v1/quote?' + queryString : 'https://api.0x.org/swap/v1/price?' + queryString;
  return $$Promise.$$catch(Axios.get(request).then(function(response) {
    const match = response.status;
    if (match === 200) {
      return Promise.resolve(response.data);
    }
    throw {
      RE_EXN_ID: Types.InvalidResponse,
      Error: new Error(),
    };
    return Promise.reject(undefined);
  }), (function(error) {
    console.log(error);
    throw {
      RE_EXN_ID: Types.InvalidResponse,
      Error: new Error(),
    };
    return Promise.reject(undefined);
  }));
}

function getTokenBalance(tokenAddress) {
  const tokenContract = new Ethers.ethers.Contract(tokenAddress, IERC20Json.abi, myProvider);
  return tokenContract.balanceOf(Constants.eth_wallet_address).then(function(balance) {
    console.log('token balance of ' + tokenAddress + ': ' + balance.toString());
    return Promise.resolve(balance);
  });
}

function getEthBalance(param) {
  return myWallet.getBalance().then(function(balance) {
    console.log('eth balance: ' + balance.toString());
    return Promise.resolve(balance);
  });
}

function approve(tokenAddress, quote) {
  const allowanceTarget = quote.allowanceTarget;
  const amount = quote.sellAmount;
  const targetContract = new Ethers.ethers.Contract(tokenAddress, IERC20Json.abi, myProvider);
  const contractWithSigner = targetContract.connect(myWallet);
  return contractWithSigner.approve(allowanceTarget, amount).then(function(tx) {
    return tx.wait().then(function(receipt) {
      console.log('approve receipt: ' + receipt);
      return Promise.resolve(receipt);
    });
  });
}

async function sendTransaction(quote) {
  // const gas = Ethers.ethers.BigNumber.from(quote.gasPrice);
  // const gas$1 = gas.mul(Constants.gas_multiple);
  const gas = await myProvider.getFeeData()
  const transaction = {
    to: Ethers.ethers.utils.getAddress(quote.to),
    data: quote.data,
    value: quote.value,
    gasPrice: gas.gasPrice,
    maxFeePerGas: gas.maxFeePerGas,
    maxPriorityFeePerGas: gas.maxPriorityFeePerGas,
  };
  return myWallet.sendTransaction(transaction).then(function(tx) {
    return tx.wait().then(function(receipt) {
      console.log('transaction receipt: ' + receipt);
      return Promise.resolve(receipt);
    });
  });
}

function mainLoop(tokenAddress, method, state) {
  if (typeof state === 'number') {
    if (state === /* First */0) {
      return $$Promise.$$catch(getEthBalance(undefined).then(function(ethBalance) {
        if (ethBalance.lt(Constants.min_eth_amount)) {
          console.log('not enough eth');
          return Promise.resolve(/* Canceled */1);
        } else {
          console.log('buying ' + tokenAddress);
          return $$Promise.$$catch(zrxQuery({
            TAG: /* HexAddress */0,
            _0: tokenAddress,
          }, {
            TAG: /* TokenName */1,
            _0: 'ETH',
          }, Constants.sell_amount, /* Quote */1, undefined).then(function(quote_0) {
            const price_0 = 1.0 / Number(quote_0.price);
            return $$Promise.$$catch(sendTransaction(quote_0).then(function(buyReceipt) {
              return $$Promise.$$catch(getTokenBalance(tokenAddress).then(function(tokenBalance) {
                return $$Promise.$$catch(zrxQuery({
                  TAG: /* TokenName */1,
                  _0: 'ETH',
                }, {
                  TAG: /* HexAddress */0,
                  _0: tokenAddress,
                }, tokenBalance.toString(), /* Quote */1, undefined).then(function(quote_approve) {
                  console.log('approving ' + tokenBalance.toString() + ' ' + tokenAddress);
                  return $$Promise.$$catch(approve(tokenAddress, quote_approve).then(function(param) {
                    return mainLoop(tokenAddress, method, {
                      TAG: /* Ongoing */0,
                      price_0: price_0,
                      price_max: price_0,
                      tokenBalance: tokenBalance.toString(),
                      buyReceipt: buyReceipt,
                    });
                  }), (function(error) {
                    console.log(error);
                    return Promise.resolve(/* Canceled */1);
                  }));
                }), (function(error) {
                  console.log(error);
                  return Promise.resolve(/* Canceled */1);
                }));
              }), (function(error) {
                console.log(error);
                return Promise.resolve(/* Canceled */1);
              }));
            }), (function(error) {
              console.log(error);
              return Promise.resolve(/* Canceled */1);
            }));
          }), (function(error) {
            console.log(error);
            return Promise.resolve(/* Canceled */1);
          }));
        }
      }), (function(error) {
        console.log(error);
        return Promise.resolve(/* Canceled */1);
      }));
    } else {
      return Promise.resolve(/* Canceled */1);
    }
  }
  if (state.TAG !== /* Ongoing */0) {
    return Promise.resolve({
      TAG: /* Success */1,
      _0: state._0,
      _1: state._1,
    });
  }
  const buyReceipt = state.buyReceipt;
  const tokenBalance = state.tokenBalance;
  const price_max = state.price_max;
  const price_0 = state.price_0;
  return $$Promise.$$catch(zrxQuery({
    TAG: /* TokenName */1,
    _0: 'ETH',
  }, {
    TAG: /* HexAddress */0,
    _0: tokenAddress,
  }, tokenBalance, /* Quote */1, undefined).then(function(quote_1) {
    const price_1 = Number(quote_1.price);
    const threshold = price_0 * Constants.profit_threshold;
    const price_max$1 = price_max > price_1 ? price_max : price_1;
    const sell = method ? price_1 < price_max$1 * (1.0 - Constants.stoploss_threshold) : price_1 > threshold;
    if (sell) {
      console.log('selling ' + tokenAddress);
      return $$Promise.$$catch(zrxQuery({
        TAG: /* TokenName */1,
        _0: 'ETH',
      }, {
        TAG: /* HexAddress */0,
        _0: tokenAddress,
      }, tokenBalance, /* Quote */1, undefined).then(function(quote_sell) {
        return $$Promise.$$catch(sendTransaction(quote_sell).then(function(sellReceipt) {
          return Promise.resolve({
            TAG: /* Success */1,
            _0: buyReceipt,
            _1: sellReceipt,
          });
        }), (function(error) {
          console.log(error);
          return Promise.resolve(/* Canceled */1);
        }));
      }), (function(error) {
        console.log(error);
        return Promise.resolve(/* Canceled */1);
      }));
    } else {
      return mainLoop(tokenAddress, method, {
        TAG: /* Ongoing */0,
        price_0: price_0,
        price_max: price_max$1,
        tokenBalance: tokenBalance,
        buyReceipt: buyReceipt,
      });
    }
  }), (function(error) {
    console.log(error);
    return Promise.resolve(/* Canceled */1);
  }));
}

myClient.on('ready', (async function(param) {
  console.log('Logged in as ' + myClient.user.tag);
  const balance = await getEthBalance(undefined);
  console.log('Eth balance: ' + balance);
}));

myClient.on('message', (async function(msg) {
  if (msg.guild.id !== Constants.discord_guild || msg.channel.id !== Constants.discord_channel) {
    return Promise.resolve(/* Canceled */1);
  }
  console.log(msg.content);
  const pairAddress = addressFromMessage(msg.content);
  console.log('token pair address: ' + pairAddress);
  if (pairAddress !== undefined) {
    return $$Promise.$$catch(tokenFromPair(pairAddress).then(function(tokenAddress) {
      console.log('token address: ' + tokenAddress);
      return mainLoop(tokenAddress, /* Stoploss */1, /* First */0);
    }), (function(param) {
      return Promise.resolve(/* Canceled */1);
    }));
  } else {
    return Promise.resolve(/* Canceled */1);
  }
}));

myClient.login(Constants.discord_token);

exports.myClient = myClient;
exports.awsProvider = awsProvider;
exports.myProvider = myProvider;
exports.myWallet = myWallet;
exports.isEthPairLink = isEthPairLink;
exports.addressFromUrl = addressFromUrl;
exports.addressFromMessage = addressFromMessage;
exports.tokenFromPair = tokenFromPair;
exports.zrxQuery = zrxQuery;
exports.getTokenBalance = getTokenBalance;
exports.getEthBalance = getEthBalance;
exports.approve = approve;
exports.sendTransaction = sendTransaction;
exports.mainLoop = mainLoop;
/* myClient Not a pure module */
